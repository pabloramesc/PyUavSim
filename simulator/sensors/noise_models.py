"""
 Copyright (c) 2022 Pablo Ramirez Escudero
 
 This software is released under the MIT License.
 https://opensource.org/licenses/MIT
"""

import numpy as np


def get_white_noise(nd: float, fs: float, nlen: int = 1) -> float | np.ndarray:
    """Generate white noise of desired characteristics.

    formula: WN_k = N / sqrt(dt) * wk

    where:
        - WN_k is white noise in instant k
        - N is noise density parameter of allan variance analysis
        - dt is de sampling period (cte, variable, average or ...)
        - wk is normal estandar gaussian distribued noise N(0,1) in instant k

    Parameters
    ----------
    nd : float
        Noise density parameter
    fs : float
        Sample rate in Hz
    nlen : int, optional
        Number of samples to return, by default 1

    Returns
    -------
    float or np.ndarray
        Simulated white noise sample or array
    """
    if nlen == 1:
        wn = nd * np.sqrt(fs) * np.random.normal(0, 1)
    elif nlen > 1:
        wn = (
            nd * np.sqrt(fs) * np.random.normal(0, 1, nlen)
        )
    return wn


def get_pink_noise(
    bi: float, tc: float, fs: float, pn_prev: float = 0.0, nlen: int = 1
) -> float | np.ndarray:
    """Generate pink (flicker) noise of desired characteristics.
    It is generated by using a gauss-markov first order process.

    formula: PN_k = (1 - beta*dt) * PN_k-1 + B * sqrt(1 - exp(-2*dt/Tc)) * wk \n
    where:
        - PN_k is pink noise in instant k
        - PN_k-1 is pink noise in the previous instant k
        - B is bias instability parameter of allan variance analysis
        - Tc is correlation time asociated with the bias instability
        - beta is the inverse of Tc (beta = 1/Tc)
        - dt is de sampling period (cte, variable, average or ...)
        - wk is normal estandar gaussian distribued noise N(0,1) in instant k

    Parameters
    ----------
    bi : float
        Bias instability parameter
    tc : float
        Correlation time parameter
    fs : float
        Sample rate in Hz
    pn_prev : float, optional
        Previous pink noise sample for iterative simulation, by default 0.0
    nlen : int, optional
        Number of samples o return, by default 1

    Returns
    -------
    float or np.ndarray
        Simulated pink noise sample or array
    """
    dt = 1.0 / fs
    beta = 1.0 / bi
    if nlen == 1:
        pn = (1.0 - beta * dt) * pn_prev + bi * np.sqrt(
            1.0 - np.exp(-2.0 * dt / tc)
        ) * np.random.normal(0, 1)
    elif nlen > 1:
        pn = np.zeros(nlen)
        for k in range(nlen):
            pn[k] = (
                1.0 - beta * dt[k]
            ) * pn_prev + bi * np.sqrt(
                1.0 - np.exp(-2.0 * dt[k] / tc)
            ) * np.random.normal(
                0, 1
            )
            pn_prev = pn[k]
    return pn


def get_brown_noise(rw: float, fs: float, bn_prev: float = 0.0, nlen: int = 1) -> float | np.ndarray:
    """Generate brown noise of desired characteristics.
    It is generated by integrating white noise.

    formula: BN_k = BN_k-1 + K * sqrt(dt) * wk \n
    where:
        - BN_k is brown noise in instant k
        - BN_k-1 is brown noise in the previous instant k
        - K is random walk parameter of allan variance analysis
        - dt is de sampling period (cte, variable, average or ...)
        - wk is normal estandar gaussian distribued noise N(0,1) in instant k

    Parameters
    ----------
    rw : float
        Random walk parameter
    fs : float
        Sample rate in Hz
    bn_prev : float, optional
        Previous brown noise sample for iterative simulation, by default 0.0
    nlen : int, optional
        Number of samples to return, by default 1

    Returns
    -------
    float or np.ndarray
        Simulated brown noise sample or array
    """
    if nlen == 1:
        bn = bn_prev + rw / np.sqrt(
            fs
        ) * np.random.normal(0, 1)
    elif nlen > 1:
        bn = bn_prev + np.cumsum(
            rw / np.sqrt(fs) * np.random.normal(0, 1, nlen)
        )
    return bn
